#+STARTUP: hidestars odd content
*Vocabulary*
* Abbreviations in stack diagrams.
  - addr :: an address in memory.
  - char :: a text character: a number that fits into one byte.
  - inchar :: an "input characte": either a *char* or the constant `#eof`.
  - flag :: a boolean flag, either 0 or -1.
  - str :: the start address of an zero-terminated string
  - cfa :: "Code Field Address": The address of a word that can be
           executed.
  - n :: a number, or sometimes an arbitrary value
  - a, b, c :: arbitray values.
* Glossary
  - cell :: A unit of memory large enough to store an integer or an
            address.
  - CFA :: code field address. This is the address of a word such that
           it can be executed.
  - flag :: A boolean value. If a word returns a flag, it is either 0,
            for "false", or -1, for true. If a word accepts a flag,
            every value different from 0 is interpreted as "true"
  - TOS :: top of Stack.
  - word :: (a) a Forth procedure,
	    (b) a sequence of non-space characters surrounded by spaces.
  - variable :: a memory region to store the value of one cell (unless
                another size is specified). If a word is called a
                variable, it returns the address of this region.
* Tags
*** immediate
    The word is always executed, even during compilation
    It has the "immediate" flag set in its header.
* Kernel words
*** Starting and Ending
***** boot
      Initialise the system completely and start the outer
      interpreter.
***** abort
      Stop the interpretation of the currently read text stream and
      return to the interactive mode by executing `'abort`.
***** 'abort		( -- addr )
      Variable that contains a word that does is called after an error
      has occured; it is expected to reset the parameter stack and the
      return stack and then to start an interactive prompt.
***** bye
      Leave the Forth system immediately.
*** Inner Interpreter
***** noop
      Do nothing.
***** ;;
      End the execution of the current word.
***** 0; 		( 0 -- | n -- n )
      If the TOS is zero, drop it and end the execution of the current
      word.
***** execute		( addr -- )
      Execute the word at addr.
*** Outer Interpreter
    These words are about reading and interpreting program text.
***** (interpret)	( addr -- )
      Search the string at *addr* in the dictionary and interpret or
      compile it, depending on the value of `state`.
***** interpret
      Read one word from the input and execute or compile it,
      depending on the the value of `state`.
***** word?		( -- addr )
      Contains a word that is executed when a string that cannot be
      found in the dictionary by `(interpret)`. At system startup, its
      value is `notfound`.

      The Forth word stored in `word` has the signature `--`; it
      expects the searched string at `here`.
***** notfound
      This word is called by default if a word is not found in the
      dictionary. It prints an error message and closes the input
      file. The word that was searched for is expected as a string at
      `here`.

      This word is the value of `word?` at startup.
***** parse-to		( addr str -- )
      Read a character sequence from the input stream and store it as
      a zero-terminated string at *addr*. The character sequence
      consists of characters not contained in the zero-terminated
      string at *str*. After reading, the reading position in the
      input stream is directly after the first character not contained
      in *str*.
***** parse		( -- addr )
      Read a whitespace-terminated word from the input stream and
      return its address. Afterwards, the reading position in the
      input stream is directly behind the first space character
      *after* that word.

      Currently the parsed word is located directly at the end of the
      dictionary.
***** \ 							  :immediate:
      Start a comment that reaches to the end of the line.
***** ( 							  :immediate:
      Start a comment that reaches to the next ")" symbol or to the
      end of the page. Note that brackets are not nested.
*** Text streams
    Text streams are an abstraction for the input of program text -
    both from a file and from strings stored in memory.
***** Text streams
      These are the basic data structures for reading program text.
******* >get-char	( 'textstream -- addr )
      	The TOS contains the address of a textstream structure: compute the
      	address of its `getchar` routine. The routine has the signature
      	( stream -- char ).
******* >eos		( 'textstream -- addr )
      	The TOS contains the address of a textstream structure: compute
      	the address of its `eos` routine. The routine has the signature
      	( stream -- bool ).	
******* >#eos		( 'textstream -- addr )
      	The TOS contains the address of a textstream structure: compute the
      	address of its `eos` field. The field is one cell wide and
      	contains the "end of stream" constant of this textstream.
******* >line#		( 'textstream -- addr )
      	The TOS contains the address of a textstream structure: compute the
      	address of its `line#` field. The field is one cell wide and
      	contains the current line number of this textstream.
******* /textstream	( -- n )
      	Number of bytes in a text stream structure.
******* 'instream	( -- addr )
	Variable that contains the address of the current text stream.
***** File streams
      A file stream is an extension of the text stream interface for
      reading from a file (or any other stream in a Unix system).

      A file stream contains all the fields of a text stream, plus
      `intext-file`.
******* >intext-file	( 'filestream -- addr )
      	The TOS contains the address of a filestream structure: compute the
      	address of its file field. The field is one cell wide and
      	contains the underlying C file pointer (FILE*) for this stream.
******* /filestream	( -- n )
      	Number of bytes in a file stream structure.
******* file-get-char	( stream -- char )
      	Read one character from a file stream and return it on the
      	stack. `line#` is updated if necessary.
******* file-eof	( stream -- flag )
      	Test whether the end of the file stream is reached.
***** get-char		( -- inchar )
      Read one character from the current stream and return it on the
      stack. `line#` is updated if necessary. If the end of the stream
      is reached and no other characters can be read, `#eos` is
      returned.
***** eos		( -- flag )
      Test whether the end of the current stream is reached.
***** #eos		( -- inchar)
      The "end of stream" constant for the current stream.
***** line#		( -- addr )
      Address of the current line number in the current stream. The
      first line of a file has the number 1.
***** do-stream
      Execute the code in the current input stream.
*** Compilation
***** [ 							  :immediate:
      Switch the interpreter to interpreting mode. All words are now
      executed.
***** ]
      Switch the interpreter to compiling mode. All words are now
      compiled, except for those that are immediate.
***** state		( -- addr )
      State of the compiler. If the value is zero, all words are
      interpreted; if it is nonzero, words are compiled and only those
      with an immediate flag are executed.
***** branch
      Unconditional jump. The cell following this word contains the
      address of the jump target.
***** 0branch		( n -- )
      Conditional jump. If *n* is zero, jump to the address in the
      next cell. If *n* is nonzero, continue with the execution of the
      word after the next cell.
***** lit		( -- n )
      Push the content of the cell after this word onto the stack.
*** Dictionary
***** align
      Increment (if necessary) the content of `dp` so that it points
      to a valid address for a cell.
***** allot		( n -- )
      Allocate n bytes at the end of the dictionary. (Afterwards, it
      may be no longer aligned.
***** ,			( n -- )
      Align the dictionary and put the cell n at its end.
***** c,		( b -- )
      Put the byte b at the end of the dictionary.
***** ,"
      Read until the next `"` and put the resulting string at the end
      of the dictionary. The space character immediately after the
      word does not belong to the string.
***** entry,		( str addr -- )
      Put a new entry at the end of the end of the dictionary. *str*
      is its name and addr is stored in its CFA field.
***** latest		( -- addr )
      Variable for the address of the latest dictionary entry.
***** dp		( -- addr )
      Dictionary Pointer. It contains the endpoint of the dictionary.
***** here		( -- addr )
      Put the current value of the dictionary pointer onto the stack.
***** (') 		( -- cfa )
      Read a word from the input and return its CFA. If it is not
      found, return 0.
***** (find)		( addr -- cfa )
      Search the string at addr in the dictionary and return its CFA.
      If it is not found, return 0.
*** Dictionary Headers
***** ^docol
***** ^dodefer
***** ^dovar
***** ^dodoes
***** link>
***** flags@
***** flags!
***** >name
***** >doer
***** #immediate
*** Return stack
***** rdrop
      Remove the top value of the return stack.
***** >r		( n -- )
      Move the TOS to the top of the return stack.
***** r>		( -- n )
      Move the top of the return stack to the TOS.
***** r@		( -- n )
      Copy the top of the return stack to the TOS.
***** r0		( -- addr )
      Variable for the position of the return stack pointer when the
      stack is empty
*** Stack
***** drop		( a -- )
***** nip		( a b -- b )
***** 2drop		( a b -- )
***** ?dup		( 0 -- 0 | n -- n n )
      Duplicate the TOS only if it is nonzero
***** dup		( a -- a a )
***** over		( a b -- a b a )
***** under		( a b -- b a b )
***** swap		( a b -- b a )
***** rot		( a b c -- b c a )
***** -rot		( a b c -- c a b )
***** sp@		( -- addr )
      Get the value of the stack pointer. `sp@ @` is equivalent to `dup`.
***** sp!		( addr -- )
      Make *addr* the new value of the stack pointer.
***** s0		( -- addr )
      Variable for the position of the stack pointer when the stack is
      empty
*** Interger Arithmetic
***** 0			( -- 0 )
      This and other numbers are defined as Forth words to shorten the
      compiled code and to make the bootstrapping of the language
      easier.
***** 1			( -- 1 )
***** -1		( -- -1 )
***** 2			( -- 2 )
***** 1+		( n -- n' )
      Add 1 to the TOS.
***** 1-		( n -- n' )
      Subtract 1 from the TOS.
***** 2*		( n -- n' )
      Multiplication with 2, as signed integer.
***** 2/		( n -- n' )
      Division by 2, as signed integer.
***** -			( n1 n2 -- n3 )
      Compute the difference n1 - n2.
***** +			( n1 n2 -- n3 )
      Compute the sum of n1 and n2.
***** *			( n1 n2 -- n3 )
      Compute the product of n1 and n2
***** /			( n1 n2 -- n3 )
      Compute the quotient n1 / n2 as integer.

      Currently this is C arithmetics, with rounding towards 0. (It
      may be changed later.)
***** mod		( n1 n2 -- n3 )
      Compute n1 mod n2
***** /mod		( n1 n2 -- quot rem )
      *quot* is n1 / n2 and *rem* is n1 mod n2.
***** u*		( n1 n2 -- n3 )
      Product of n1 and n2 as unsigned integers.
***** u/		( n1 n2 -- n3 )
      Quotient of n1 and n2 as unsigned integer.
***** abs		( n -- u )
      Compute the absolute value
*** Binary Arithmetic
***** false		( -- flag )
      Boolean flag for false,
***** true		( -- flag )
      Boolean flag for true.
***** or		( n1 n2 -- n3 )
      Bitwise "or" of n1 and n2.
***** and		( n1 n2 -- n3 )
      Bitwise "and" of n1 and n2.
***** xor		( n1 n2 -- n3 )
      Bitwise exclusive "or" of n1 and n2.
***** invert		( n1 -- n2 )
      Bitwise nagation of the TOS.
*** Comparisons
***** =			( n1 n2 -- flag )
      Test whether n1 and n2 are equal.
***** <>		( n1 n2 -- flag )
      Test whether n1 and n2 are unequal.
***** 0=		( n -- flag )
      Test whether the TOS is equal to 0. (This also inverts boolean
      flags.)
***** 0<		( n -- flag )
      Test whether TOS < 0
***** 0>		( n -- flag )
      Test whether TOS > 0
***** <			( n1 n2 -- flag )
      Test whether n1 < n2.
***** <=		( n1 n2 -- flag )
      Test whether n1 <= n2.
***** >			( n1 n2 -- flag )
      Test whether n1 > n2.
***** >=		( n1 n2 -- flag )
      Test whether n1 >= n2.
***** u<		( n1 n2 -- flag )
      Test whether n1 < n2 as unsigned integers.
***** u<=		( n1 n2 -- flag )
      Test whether n1 <= n2 as unsigned integers.
***** u>		( n1 n2 -- flag )
      Test whether n1 > n2 as unsigned integers.
***** u>=		( n1 n2 -- flag )
      Test whether n1 >= n2 as unsigned integers.
***** within		( n n0 n1 -- flag )
      True if n0 <= n <= n1. The sequence of integers is here viewed
      as cyclic; the word works therefore with unsigned integers as
      well as with signed ones.
*** Memory
***** @			( addr -- n )
      Fetch the cell at *addr*.
***** c@		( addr -- n )
      Fetch the byte at *addr*.
***** !			( n addr -- )
      Store one cell at *addr*.
***** +!		( n addr -- )
      Add *n* to the cell at *addr*.
***** c!		( n addr -- )
      Store one byte at *addr*.
***** malloc		( n -- addr )
      Allocate *n* bytes of memory and return its address. Return 0 if
      the allocation fails.
***** free		( addr -- )
      Free the memory space at *addr*, which must have been allocated
      by `malloc`.
***** cells		( n1 -- n2 )
      Compute the number of bytes used by *n1* cells.
***** cell+		( addr1 -- addr2 )
      Increment the TOS by the size of one cell.
***** cell-		( addr1 -- addr2 )
      Decrement the TOS by the size of one cell.
*** Strings
***** append		( addr char -- addr' )
      Store *char* at *addr* and add 1 to *addr*. This word can be
      used to build incrementally a string in memory.
***** append-from	( addr inchar str -- addr' )
      If *inchar* is contained in *str* and it is not the current
      `eos` constant, store it at *addr* and add 1 to *addr*.
      Otherwise do nothing.
***** append-notfrom	( addr inchar str -- addr' )
      If *inchar* is not contained in *str* and it is not the current
      `eos` constant, store it at *addr* and add 1 to *addr*.
      Otherwise do nothing.
***** strlen		( addr -- n )
      Return the length of the string starting at *addr*, without the
      trailing 0 byte.
***** strchr		( str char -- addr )
      If *char* is contained in *str*, then return the position of its
      first occurrence. Othewise return 0.
***** bl		( -- char )
      Code for the "blank" character.

      - Source :: Forth 83
***** #eol		( -- char )
      Code for the "end of line" character.
***** #eof		( -- inchar )
      Code for the "end of file" constant (which is *not* a character)
***** whitespace	( -- str )
      Zero-terminated string that contains all the characters that are
      viewed as whitespace by Mind.

*** Input/Output
***** emit		( n -- )
      Send the character with number *n* to the output.
***** type		( addr n -- )
      Send the sequence of characters of length *n* starting at *addr*
      to the output.
***** puts		( addr -- )
      Send the zero-terminated string beginning at *addr* to the
      output.
***** gets		( addr n -- str )
      An interface to the function `fgets()` from libc.

      The word reads characters from standard input until a return
      character is encountered or *n* - 1 characters are read. A
      zero-terminated string with these characters is created at
      *addr*. The string contains the terminating end-of-line
      character, if one has been typed.

      If no characters could be read from standard input because the
      standard input is in an end-of-file state, the return value is
      0, and nothing is written to the buffer at *addr*, not even a
      terminating zero.
***** accept		( addr n -- n' )
      Read a line from the standard input and store it as a
      zero-terminated string with maximal length *n* in the buffer at
      *addr*. The buffer must therefore be at least *n* + 1 bytes
      wide. A line ends if the maximal number of characters is read, a
      return character is encountered, or the input stream has ended.
      If a return has been typed, it is not part of the string.

      The return value is the number of bytes actually read.
      - Source :: Reva, ANSI. Modified for zero-terminated strings.
***** .(
      Print the characters that follow this word in the input file to
      the output, until the next ")". The closing bracket is not
      printed.
***** cr
      Begin a new output line.
***** h.		( addr -- )
      Print the TOS as a hexadecimal number, followed by a space.
