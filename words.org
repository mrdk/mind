#+STARTUP: hidestars
#+STARTUP: odd
*Vocabulary*
* Abbreviations in stack diagrams.
  - addr :: an address in memory.
  - cfa :: "Code Field Address": The address of a word that can be
           executed.
  - n :: a number, or sometimes an arbitrary value
  - a, b, c :: arbitray values.
* Glossary
  - cell :: A unit of memory large enough to store an integer or an
            address.
  - CFA :: code field address. This is the address of a word such that
           it can be executed.
  - flag :: A boolean value. If a word returns a flag, it is either 0,
            for "false", or -1, for true. If a word accepts a flag,
            every value different from 0 is interpreted as "true"
  - TOS :: top of Stack.
  - word :: (a) a Forth procedure,
	    (b) a sequence of non-space characters surrounded by spaces.
* Tags
*** immediate
    The word is always executed, even during compilation
    It has the "immediate" flag set in its header.
* Kernel words
*** Starting and Ending
***** boot
      Initialise the system completely and start the outer
      interpreter.
***** abort
      Reset the stack and the return stack and start the outer
      interpreter.
***** quit
      Reset the return stack and start the outer interpreter.
***** bye
      Leave the Forth system immediately.
*** Inner Interpreter
    These words are related to the interpretation of compiled Forth
    code.
***** noop
      Do nothing.
***** ;;
      End the execution of the current word.
***** 0; 		0 -- | n -- n
      If the TOS is zero, drop it and end the execution of the current
      word.
***** execute		addr --
      Execute the word at addr.
***** ^docol
***** ^dodefer
***** ^dovar
***** ^dodoes
*** Outer interpreter
    These words are related to the interpretation of text.
***** interpret
      Read one word from the input and execute or compile it,
      depending on the state of the interpreter.
***** notfound
      This word is called by default if a word is not found in the
      dictionary. It prints an error message and closes the input
      file. The word that was searched for is expected as a string at
      `here`.

      This word is the value of `word?` at startup.
***** (') 		-- cfa
      Read a word from the input and return its CFA. If it is not
      found, return 0.
***** (find)		addr -- cfa
      Search the string at addr in the dictionary and return its CFA.
      If it is not found, return 0.
***** [ 							  :immediate:
      Switch the interpreter to interpreting mode. All words are now
      executed.
***** ]
      Switch the interpreter to compiling mode. All words are now
      compiled, except for those that are immediate.
***** get-char		-- n
      Read one character from the input stream and return it on the
      stack.
***** \ 							  :immediate:
      Start a comment that reaches to the end of the line.
***** ( 							  :immediate:
      Start a comment that reaches to the next ")" symbol or to the
      end of the page. Note that brackets are not nested.
*** Dictionary
***** align
      Align the end of the dictionary for a cell.
***** allot		n --
      Allocate n bytes at the end of the dictionary. (Afterwards, it
      may be no longer aligned.
***** ,			n --
      Align the dictionary and put the cell n at its end.
***** c,		b --
      Put the byte b at the end of the dictionary.
***** ,"
      Read until the next `"` and put the resulting string at the end
      of the dictionary. The space character immediately after the
      word does not belong to the string.
***** parse		-- addr
      Read a space-terminated word from the input stream and return
      its address. Afterwards, the reading position in the input
      stream is directly behind the first space character *after* that
      word.

      Currently the parsed word is located directly at the end of the
      dictionary.
***** TODO entry,	str addr --
      Put a new entry at the end of the end of the dictionary. *str*
      is its name and addr is stored in its CFA field.
***** link>
***** flags@
***** flags!
***** >name
***** >doer
***** #immediate
*** Inline constants
***** branch
      Unconditional jump. The cell following this word contains the
      address of the jump target.
***** 0branch		n --
      Conditional jump. If *n* is zero, jump to the address in the
      next cell. If *n* is nonzero, continue with the execution of the
      word after the next cell.
***** lit		-- n
      Push the content of the cell after this word onto the stack.
*** System variables
***** s0		-- addr
      Variable for the position of the stack pointer when the stack is
      empty
***** r0		-- addr
      Variable for the position of the return stack pointer when the
      stack is empty
***** latest		-- addr
      Variable for the address of the latest dictionary entry.
***** dp		-- addr
      Dictionary Pointer. It contains the endpoint of the dictionary.
***** here		-- addr
      Put the current value of the dictionary pointer onto the stack.
***** state		-- addr
      State of the compiler. If the value is zero, all words are
      interpreted; if it is nonzero, words are compiled and only those
      with an immediate flag are executed.
***** word?		-- addr
      Contains a word that is executed when a string that cannot be
      found in the dictionary. At system startup, its value is
      `notfound`.

      The Forth word stored in `word` has the signature `--`; it
      expects the searched string at `here`.
***** line#		-- addr
      Contains the current line number in the input file. The line
      number is relative to the beginning of the page.
***** page#		-- addr
      Contains the current page number in the input file. A new page
      begins in the text whenever a Ctrl-L character is encountered.
*** Return stack
***** rdrop
      Remove the top value of the return stack.
***** >r		n --
      Move the TOS to the top of the return stack.
***** r>		-- n
      Move the top of the return stack to the TOS.
***** r			-- n
      Copy the top of the return stack to the TOS.
*** Stack
***** drop		a --
***** nip		a b -- b
***** 2drop		a b --
***** ?dup		0 -- 0 | n -- n n
      Duplicate the TOS only if it is nonzero
***** dup		a -- a a
***** over		a b -- a b a
***** under		a b -- b a b
***** swap		a b -- b a
***** rot		a b c -- b c a
***** -rot		a b c -- c a b
***** sp@		-- addr
      Get the value of the stack pointer. `sp@ @` is equivalent to `dup`.
***** sp!		addr --
      Make *addr* the new value of the stack pointer.
*** Arithmetics
***** false		-- flag
      Boolean flag for false,
***** true		-- flag
      Boolean flag for true.
***** 0			-- 0
      This and other numbers are defined as Forth words to shorten the
      compiled code and to make the bootstrapping of the language
      easier.
***** 1			-- 1
***** -1		-- -1
***** 2			-- 2
***** 1+		n -- n'
      Add 1 to the TOS.
***** 1-		n -- n'
      Subtract 1 from the TOS.
***** 2*		n -- n'
      Multiplication with 2, as signed integer.
***** 2/		n -- n'
      Division by 2, as signed integer.
***** -			n1 n2 -- n3
      Compute the difference n1 - n2.
***** +			n1 n2 -- n3
      Compute the sum of n1 and n2.
***** *			n1 n2 -- n3
      Compute the product of n1 and n2
***** /			n1 n2 -- n3
      Compute the quotient n1 / n2 as integer.

      Currently this is C arithmetics, with rounding towards 0. (It
      may be changed later.)
***** mod		n1 n2 -- n3
      Compute n1 mod n2
***** /mod		n1 n2 -- quot rem
      *quot* is n1 / n2 and *rem* is n1 mod n2.
***** u*		n1 n2 -- n3
      Product of n1 and n2 as unsigned integers.
***** u/		n1 n2 -- n3
      Quotient of n1 and n2 as unsigned integer.
***** abs		n -- u
      Compute the absolute value
***** or		n1 n2 -- n3
      Bitwise "or" of n1 and n2.
***** and		n1 n2 -- n3
      Bitwise "and" of n1 and n2.
***** xor		n1 n2 -- n3
      Bitwise exclusive "or" of n1 and n2.
***** invert		n1 -- n2
      Bitwise nagation of the TOS.
***** =			n1 n2 -- flag
      Test whether n1 and n2 are equal.
***** <>		n1 n2 -- flag
      Test whether n1 and n2 are unequal.
***** 0=		n -- flag
      Test whether the TOS is equal to 0. (This also inverts boolean
      flags.)
***** 0<		n -- flag
      Test whether TOS < 0
***** 0>		n -- flag
      Test whether TOS > 0
***** <			n1 n2 -- flag
      Test whether n1 < n2.
***** <=		n1 n2 -- flag
      Test whether n1 <= n2.
***** >			n1 n2 -- flag
      Test whether n1 > n2.
***** >=		n1 n2 -- flag
      Test whether n1 >= n2.
***** u<		n1 n2 -- flag
      Test whether n1 < n2 as unsigned integers.
***** u<=		n1 n2 -- flag
      Test whether n1 <= n2 as unsigned integers.
***** u>		n1 n2 -- flag
      Test whether n1 > n2 as unsigned integers.
***** u>=		n1 n2 -- flag
      Test whether n1 >= n2 as unsigned integers.
***** within		n n0 n1 -- flag
      True if n0 <= n <= n1. The sequence of integers is here viewed
      as cyclic; the word works therefore with unsigned integers as
      well as with signed ones.
*** Memory
***** @			addr -- n
      Fetch the cell at *addr*.
***** c@
      Fetch the byte at *addr*.
***** !			n addr --
      Store one cell at *addr*.
***** +!		n addr --
      Add *n* to the cell at *addr*.
***** c!		n addr --
      Store one byte at *addr*.
***** malloc		n -- addr
      Allocate *n* bytes of memory and return its address. Return 0 if
      the allocation fails.
***** free		addr
      Free the memory space at *addr*, which must have been allocated
      by `malloc`.
***** cells		n1 -- n2
      Compute the number of bytes used by *n1* cells.
***** cell+		addr1 -- addr2
      Increment the TOS by the size of one cell.
***** cell-		addr1 -- addr2
      Decrement the TOS by the size of one cell.
*** Input/Output
***** strlen		addr -- n
      Return the length of the string starting at *addr*, without the
      trailing 0 byte.
***** emit		n --
      Send the character with number *n* to the output.
***** type		addr n --
      Send the sequence of characters of length *n* starting at *addr*
      to the output.
***** puts		addr --
      Send the null-terminated string beginning at *addr* to the
      output.
***** cr
      Begin a new output line.
***** h.		addr --
      Print the TOS as a hexadecimal number, followed by a space.
***** bl		-- n
      Code for a blank character.
*** Others
***** .(
      Print the characters that follow this word in the input file to
      the output.
