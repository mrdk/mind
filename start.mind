\ Defining words						. o ( mind )
.( Line: ) line# @ h.  cr

here ," Create-as"  ^docol entry,	( 'interpreter "name" -- )
	] parse  dup strlen 1+ allot  swap entry,  ;; [

^dodefer Create-as ?pairs  (') 2drop ,  ( n1 n2 -- ) 

^docol Create-as :			( "name" -- )
	] ^docol Create-as  1 state !   lit :  ;; [
: ;	lit : ?pairs   lit ;; ,   0 state !   ;; [
        drop                                    \ drop flag created by :
	#immediate  latest @ link>  flags!	\ make immediate

: 'latest ( -- cfa )    latest @ link> ;
: immediate   'latest dup flags@  #immediate or  swap flags! ;

: Create  ^dovar Create-as ;
: does>   'latest  ^dodoes over !   r> swap >doer ! ;

: Variable ( -- )     Create  1 cells allot ;
: Constant ( n -- )   Create ,  does> @ ;

: Defer    ( cfa -- )   ^dodefer Create-as , ;


\ Literals

(') drop Defer ?exists ( cfa -- ) \ Abort if word does not exist

: '	  ( -- cfa )   (') dup ?exists ;
: literal,  ( n -- )   lit lit ,  , ; \ create { ' lit | n } in dict.

' literal, Defer literal ( n -- ) immediate

: [']   ' literal, ; immediate
: [compile]  	' , ; immediate


\ Control structures

: >mark    ( -- a )	align  here 0 , ;
: >resolve ( a -- )	align  here swap ! ;

: <mark    ( -- a )	align here ;
: <resolve ( a -- )	, ;
: >resolve-all ( a1 ... an n -- )    0;  swap >resolve  1- >resolve-all ;


: IF   ( -- a )      ['] 0branch ,  >mark ;  immediate
: ELSE ( a1 -- a2 )  ['] branch ,   >mark  swap >resolve ;  immediate
: THEN ( a -- )      >resolve ;  immediate

: BEGIN ( -- 0 a )	0 <mark ;  immediate
: WHILE ( n a -- a' n+1 a )
    >r  ['] 0branch ,  >mark  swap 1+  r> ;  immediate
: REPEAT ( a1 ... an n a -- )
    ['] branch ,  <resolve  >resolve-all ;  immediate


\ Inlined strings

\ data structure: { ' inline-data | ' end | data ... | }
\ return address of data following in code, relative to the word
\ calling inline-data
: inline-data ( -- a )   r> r>   dup @ >r  cell+  swap >r ;

: (.")  ( -- )     inline-data puts ;
: (")   ( -- a )   inline-data ;

: Stringlit ( cfa -- )   Create ,  immediate  does>  @ ,  >mark  ," >resolve ;

' (.") Stringlit ."
' (")  Stringlit  "


\ Characters

: char ( -- c )		parse c@ ;
: [char]	char literal, ;  immediate

: space    bl emit ;
: spaces ( n -- )  BEGIN  ?dup WHILE 1- space REPEAT ;


\ Debug tools

: .abort    ( str -- )	       ." Abort: "  here puts  space puts  cr ;
: do-abort  ( flag str -- )    swap IF .abort  abort  ELSE drop THEN ;
: (abort")  ( f -- )   inline-data do-abort ;
' (abort") Stringlit abort"

: depth ( -- n )   s0 @ cell-  sp@ - [ 1 cells ] literal  / ;
: ?stack   depth 0< abort" Stack empty" ;

: .s    ?stack  sp@ >r  s0 @
    BEGIN  dup r u> WHILE  cell-  dup @ h.  REPEAT  drop rdrop ;


\ Conversion: string > number

: within+  ( n n0 n1 -- flag )	1+ within ; \ true if n0 <= n <= n1

Variable base	2 base !	\ Base for number conversion.

Variable #acc			\ Number accumulator
: accumulate ( n -- )	#acc @  base @ u* +  #acc ! ;

: digit?     ( n -- ? )	base @ u< ;
: digit>#  ( c -- n ? )
  dup  [char] 0 [char] 9 within+  IF  [char] 0 -  dup digit? ;; THEN
  dup  [char] a [char] z within+  IF  [char] a -
                     [ 1 2* 2* 1+ 2* ] literal +  dup digit? ;; THEN
  false ;			 

: udigits    ( a -- a' )	\ Accumulate first unsigned digits
  BEGIN dup c@  digit># IF accumulate ELSE drop ;; THEN  1+ REPEAT ;
: ?rest    ( a -- )	c@ abort" not found" ;	\ Abort if not a number
: >unumber ( a -- n )	0 #acc !  udigits ?rest  #acc @ ;

: get-sign ( a -- a' sign )	dup c@  [char] - =  IF 1+  -1 ELSE 1 THEN ;
: >number  ( a -- n ) 	   	get-sign swap  >unumber  * ;


\ Add number conversion to the outer interpreter

: convert-number   here >number  state @ IF literal, THEN ;
' convert-number word? !     \ Activate number conversion


1010 base !   \ going decimal

: binary     2 base ! ;
: octal      8 base ! ;
: decimal   10 base ! ;
: hex       16 base ! ;


\ Conversion: numbers > string (Modified f.i.g. model.)

128 Constant /numbuf
Create numbuf  /numbuf 1+ allot 
Variable 'num	    \ points to the beginning of the generated string.

: hold   ( char -- )  -1 'num +!   'num @  c! ;
: hold-sign ( n -- )   dup 0< IF  [char] - hold  ELSE drop THEN ;
: <#	 numbuf /numbuf + 'num !   0 hold ;
: # ( u -- u')	    base @ u/mod
  dup 10 <  IF [char] 0 +  ELSE  10 - [char] a +  THEN  hold ;
: #s ( u -- )	    BEGIN  ?dup WHILE  # REPEAT ;
: #> ( -- addr )    'num @ ;

: (u.)  ( u -- )    <# # #s #> puts ;
: u.    ( u -- )    (u.) space ;
: (.)   ( n -- )    dup abs  <# # #s hold-sign #>  puts ;
: .     ( n -- )    (.) space ;


\ Words

: .name   ( cfa -- )   >name puts ;
: words   latest  BEGIN @  ?dup WHILE  dup link> .name space  REPEAT ;


\ Last page
.( Line: ) line# @ .  cr

\ Local Variables:
\ comment-start: "\\ "
\ End:
