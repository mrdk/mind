\ Defining words						. o ( mind )

here ," Create-as"  ^docol entry,	( 'interpreter "name" -- )
	] parse  dup strlen 1+ allot  swap entry,  ;; [

^dodefer Create-as ?pairs               ( n1 n2 -- ) 
(') 2drop  (') ?pairs >doer !

^docol Create-as :			( "name" -- )
	] ^docol Create-as  1 state !   lit :  ;; [ drop
: ;	   lit : ?pairs   lit ;; ,   0 state !   ;; [
    drop                               \ drop flag created by `:`
	#immediate  latest @ link>  flags! \ make immediate


: 'latest ( -- cfa )    latest @ link> ;
: immediate   'latest dup flags@  #immediate or  swap flags! ;

: Create   ^dovar Create-as ;
: does>    ^dodoes 'latest !   r> 'latest >doer ! ;

: Variable ( -- )     Create  1 cells allot ;
: Constant ( n -- )   Create ,  does> @ ;

: Defer    ( cfa -- )   ^dodefer Create-as  'latest >doer ! ;


\ Literals

(') drop Defer ?exists ( cfa -- ) \ Abort if word does not exist

: '	  ( "word" -- cfa )   (')  dup ?exists ;

: literal,  ( n -- )            \ create { ' lit | n } in code.
  lit lit ,  , ;

' literal, Defer literal ( n -- ) immediate

: [']       ( "word" -- )       \ Compile the CFA of the following word
  ' literal, ; immediate
: [compile] ( "word" -- )       \ Compile the following word
  ' , ;        immediate
: is    ( cfa "word" -- )       \ Set behaviour of Defer word
  ' >doer ! ;

\ Control structures

: >mark    ( -- a )	align  here 0 , ;
: >resolve ( a -- )	align  here swap ! ;

: <mark    ( -- a )	align here ;
: <resolve ( a -- )	, ;
: >resolve-all ( a1 ... an n -- )    0;  swap >resolve  1- >resolve-all ;


: IF   ( -- a )      ['] 0branch ,  >mark ;  immediate
: ELSE ( a1 -- a2 )  ['] branch ,   >mark  swap >resolve ;  immediate
: THEN ( a -- )      >resolve ;  immediate

: BEGIN ( -- 0 a )	0 <mark ;  immediate
: WHILE ( n a -- a' n+1 a )
    >r  ['] 0branch ,  >mark  swap 1+  r> ;  immediate
: REPEAT ( a1 ... an n a -- )
    ['] branch ,  <resolve  >resolve-all ;  immediate


\ Number Comparison

: within+  ( n n0 n1 -- flag )	1+ within ; \ true if n0 <= n <= n1

: max ( n1 n2 -- n3 )   2dup <  IF nip ELSE drop THEN ; \ Maximum of n1 and n2
: min ( n1 n2 -- n3 )   2dup <  IF drop ELSE nip THEN ; \ Minimum of n1 and n2


\ Inlined strings

\ data structure: { ' inline-data | ' end | data ... | }
\ return address of data following in code, relative to the word
\ calling `inline-data`
: inline-data ( -- addr )   rr> dup @ >rr  cell+ ;

: (.")  ( -- )       inline-data puts ; \ Print inlined string
: (")   ( -- addr )  inline-data ;      \ Address of inlined string

: Stringlit ( cfa -- )   Create ,  immediate  does>  @ ,  >mark  ," >resolve ;

' (.") Stringlit ."
' (")  Stringlit  "


\ Characters

: char   ( "char" -- c )        \  Ascii (or other) code for "char"
  parse c@ ;
: [char] ( Compile: "char" -- c ) \ Compile code for "char"
  char literal, ;  immediate

: space    bl emit ;            \ Print a single space
: spaces  ( n -- )              \ Print n spaces
  0 max  BEGIN  ?dup WHILE 1- space REPEAT ;


\ Debug tools

: .abort    ( str -- )	       ." Abort: "  here puts  space  puts  cr ;
: do-abort  ( flag str -- )    swap IF .abort  abort  ELSE drop THEN ;
: (abort")  ( f -- )   inline-data do-abort ;
' (abort") Stringlit abort"

: depth ( -- n )   s0 @   sp@ - [ 1 cells ] literal  / ;
: ?stack   depth 0< abort" Stack empty" ;

: (?pairs)  ( n1 n2 -- )    <> abort" Mismatching control structure" ;
' (?pairs) is ?pairs


\ Conversion: string to number

Variable base		    \ Base for number conversion.

Variable #acc			\ Number accumulator
: accumulate ( n -- )   \ Put n as new last digit into #acc
  #acc @  base @ u* +  #acc ! ;

: digit?   ( n -- ? )	base @ u< ; \ is n a digit under the current base?
: digit>#  ( char -- n ? )
  dup  [char] 0 [char] 9 within+  IF  [char] 0 -  dup digit? ;; THEN
  dup  [char] a [char] z within+  IF  [char] a -
                [ char 9 char 0 - 1+ ] literal +  dup digit? ;; THEN
  false ;			 

: udigits  ( str -- str' )      \ accumulate unsigned digits as long as possible
  BEGIN dup c@  digit># IF accumulate ELSE drop ;; THEN  1+ REPEAT ;
: ?rest    ( str -- )           \ abort if there are unconverted characters
  c@ abort" not found" ;
: >unumber ( str -- n )         \ convert string to unsigned number
  0 #acc !  udigits ?rest  #acc @ ;

: get-sign ( str -- a' sign )   \ read leading minus sign if it is there
  dup c@  [char] - =  IF 1+  -1 ELSE 1 THEN ;
: >number  ( str -- n )         \ convert string to signed number
  get-sign swap  >unumber  * ;


\ Add number conversion to the outer interpreter

: convert-number             \ Convert number at `here`, compile it if necessary
  here >number  state @ IF literal, THEN ;

' convert-number word? !        \ Activate number conversion


2 base !
1010 base !   \ going decimal

: binary     2 base ! ;
: octal      8 base ! ;
: decimal   10 base ! ;
: hex       16 base ! ;


\ Conversion: numbers to string (Modified f.i.g. model.)

128 Constant /numbuf
Create numbuf  /numbuf 1+ allot 
Variable 'num                  \ points to the beginning of the generated string

: #>digit ( n - char )
  dup 10 <  IF [char] 0 +  ELSE  10 - [char] a +  THEN ;

: hold   ( char -- )  -1 'num +!   'num @  c! ;
: hold-sign ( n -- )   0< IF  [char] - hold  THEN ;

: <#	            numbuf /numbuf + 'num !   0 hold ;
: # ( u -- u')	    base @ u/mod  #>digit hold ;
: #s ( u -- )	    BEGIN  ?dup WHILE  # REPEAT ;
: #> ( -- addr )    'num @ ;

: (u.)  ( u -- addr )    <# # #s #> ;
: u.    ( u -- )    (u.) puts space ;
: (.)   ( n -- addr )    dup abs  <# # #s hold-sign #> ;
: .     ( n -- )    (.)  puts space ;


\ Line input

: ?split   ( addr c -- )     \ if character at `addr` is `c`, split string there
  over c@ = IF  0 swap c!  ELSE drop THEN ;
: chomp  ( str -- )             \ remove trailing end-of-line character.
  dup strlen + 1-  #eol  ?split ;

: accept  ( addr n -- n' )
  over swap  1+ gets IF  dup chomp strlen ELSE  0 swap c!  drop 0 THEN ;

256 Constant /linebuf
Create linebuf  /linebuf 1+ allot


0 cell+ Constant /cell

: perform ( `xt -- )   @ execute ;

: later   rr> >r ;
: push ( addr -- )       \ Save content of addr during execution of current word
  dup >rr @ >rr  later  r> r> ! ;

: h. ( n -- )   base push  hex . ;


: Textstream	Create /textstream allot ;

: Field  ( offset size -- offset' )   Create over ,  +
  does>  ( 'base -- 'field )          @ + ;

/textstream
  /cell Field >'current-char         \ points to the current character
Constant /stringstream

: strstream-forward   ( 'stream -- )        >'current-char  1 swap +! ;
: strstream-current@  ( 'stream -- char )   >'current-char @ c@ ;
: strstream-eos       ( 'stream -- flag )   strstream-current@ 0= ;

: Stringstream  Create here  /stringstream allot
  ['] strstream-forward  over >forward !
  ['] strstream-current@ over >current@ !
  ['] strstream-eos      over >eos !
  0 over >#eos !
  drop ;

: interpret-stream ( 'string 'stream -- )
  'instream push  dup 'instream !  >'current-char !  do-stream ;

Stringstream line-stream

: line-interpret
  BEGIN  linebuf /linebuf accept drop
         linebuf line-stream interpret-stream
         ." ok" cr  REPEAT ;

' line-interpret 'abort !

\ Debug and Display

: .s                            \ print content of stack
  ?stack  sp@ >r  s0 @  BEGIN  dup r@ u>= WHILE  dup @ h.  cell- REPEAT
  drop rdrop ;

: .name   ( cfa -- )   >name puts ;
: words   latest  BEGIN @  ?dup WHILE  dup link> .name space  REPEAT ;


\ Local Variables:
\ comment-start: "\\ "
\ End: