\ mind -- a Forth interpreter					. o ( mind )
\ Copyright 2011-2013 Markus Redeker <cep@ibp.de>
\
\ Published under the GNU General Public License version 2 or any
\ later version, at your choice. There is NO WARRANY, not at all. See
\ the file "copying" for details.

\ The words that are marked with a (L) belong to the core language;
\ they are not just implementation details.

\ Defining words

:, 'latest ( -- xt )  ] latest @ link>  ;; [
:, immediate                    \ (L)
   ] 'latest dup flags@  #immediate or  swap flags! ;; [

:, Alias ( xt -- )    ] ^dodefer Create,  'latest >doer ! ;; [ \ (L)

(') 2drop Alias ?pairs ( n1 n2 -- )

:, : ( <word> -- )    ] :,  1 state !   lit :  ;; [   \ (L)
:, ;                                                  \ (L)
   ] lit : ?pairs  lit ;; ,   0 state !  ;; [  immediate


: Create   ^dovar Create, ;   \ (L)
: does>    ^dodoes 'latest !   r> 'latest >doer ! ; \ (L)

: Variable ( -- )     Create  1 cells allot ; \ (L)
: Constant ( n -- )   Create ,  does> @ ;     \ (L)


\ Literals

(') drop Alias ?exists ( xt -- ) \ abort if word does not exist

: '	  ( <word> -- xt )   (')  dup ?exists ;

: literal,  ( n -- )            \ create { ' lit | n } in code.
  lit lit ,  , ;

' literal, Alias literal ( n -- ) immediate

: ['] ( <word> --; Compile: -- xt )
  ' literal, ; immediate        \ Compile the XT of the following word
: [compile] ( <word> -- )       \ Compile the following word
  ' , ;        immediate
: is    ( xt <word> -- )       \ Set behaviour of `Alias` word
  ' >doer ! ;


\ Control structures

: >mark    ( -- a )	align  here 0 , ;
: >resolve ( a -- )	align  here swap ! ;

: <mark    ( -- a )	align here ;
: <resolve ( a -- )	, ;

: if,   ( -- addr )         ['] 0branch ,  >mark ;     \ (L)
: else, ( addr1 -- addr2 )  ['] branch ,   >mark  swap >resolve ; \ (L)
: then, ( addr -- )         >resolve ;                            \ (L)

: ?then ( flag -- )             \ Are we inside an IF-ELSE-THEN structure?
  dup ['] if, <> [ if, ] ['] else, ?pairs [ else, ] drop [ then, ] ;

: IF   ( -- addr flag )       
  if,  ['] if, ;  immediate     \ (L)
: ELSE ( addr1 flag1 -- addr2 flag2 )
  ['] if, ?pairs  else,  ['] else, ;  immediate \ (L)
: THEN ( addr flag -- )        
  ?then then, ;  immediate      \ (L)

: begin,  ( -- a )        <mark ; \ (L)
: while,  ( a -- a' a )   if, swap ; \ (L)
: repeat, ( a -- )        ['] branch ,  <resolve ; \ (L)

: BEGIN ( -- 0 a )             
  0  begin,  ['] begin, ;  immediate \ (L)
: WHILE ( a -- a' a )
  ['] begin, ?pairs  while,  ['] begin, ;  immediate \ (L)
: REPEAT ( 0 a'1 ... a'n a -- )
  ['] begin, ?pairs  repeat,
  [ begin, ]  0;  then, [ repeat, ] ;  immediate \ (L)


\ Number Comparison

: within+  ( n n0 n1 -- flag )	1+ within ; \ true if n0 <= n <= n1

: ?nip ( n1 n2 flag -- n3 ) IF nip ELSE drop THEN ;
: max ( n1 n2 -- n3 )   2dup <  ?nip ; \ Maximum of n1 and n2 (L)
: min ( n1 n2 -- n3 )   2dup >  ?nip ; \ Minimum of n1 and n2 (L)


\ Inlined strings

\ data structure: { ' 'inlined | ' end | data ... | }
\ return address of data following in code, relative to the word
\ calling `'inlined`
: 'inlined ( -- addr )   rr> dup @ >rr  cell+ ;

: (.")  ( -- )       'inlined puts ; \ Print inlined string (L)
: (")   ( -- addr )  'inlined ;      \ Address of inlined string (L)

: Stringlit ( xt -- )   Create ,  immediate  does>  @ ,  >mark  ," >resolve ;

' (.") Stringlit ."             \ (L)
' (")  Stringlit  "             \ (L)


\ Characters

: char   ( "char" -- c )        \  Ascii (or other) code for "char"
  parse c@ ;
: [char] ( "char" --; Compile: -- c ) \ Compile code for "char"
  char literal, ;  immediate

: space    bl emit ;            \ Print a single space
: spaces  ( n -- )              \ Print n spaces
  0 max  BEGIN  ?dup WHILE 1- space REPEAT ;


\ Debug tools

: .abort    ( str -- )	       ." Abort: "  here puts  space  puts  cr ;
: do-abort  ( flag str -- )    swap IF  .abort abort  ELSE drop THEN ;
: (abort")  ( flag -- )        'inlined do-abort ;
' (abort") Stringlit abort"

: depth ( -- n )                \ Number of entries on the stack
  s0 @   sp@ - [ 1 cells ] literal  / ;
: ?stack   depth 0< abort" Stack empty" ;

: (?pairs)  ( n1 n2 -- )    <> abort" Mismatching control structure" ;
' (?pairs) is ?pairs

: no-defer   true abort" undefined Defer" ; \ (L)
: Defer      ['] no-defer Alias ; \ (L)


\ Conversion: string to number

Variable base                   \ Base for number conversion.

Variable #acc                   \ Number accumulator
: accumulate ( n -- )           \ Put n as new last digit into #acc
  #acc @  base @ * +  #acc ! ;

: digit?   ( n -- ? )	base @ u< ; \ is n a digit under the current base?
: digit>#  ( char -- n ? )
  dup  [char] 0 [char] 9 within+  IF  [char] 0 -  dup digit? ;; THEN
  dup  [char] a [char] z within+  IF  [char] a -
                [ char 9 char 0 - 1+ ] literal +  dup digit? ;; THEN
  false ;

: udigits  ( str -- str' )      \ accumulate unsigned digits as long as possible
  BEGIN dup c@  digit># IF accumulate ELSE drop ;; THEN  1+ REPEAT ;
: ?rest    ( str -- )           \ abort if there are unconverted characters
  c@ abort" not found" ;
: >unumber ( str -- n )         \ convert string to unsigned number
  0 #acc !  udigits ?rest  #acc @ ;

: get-sign ( str -- a' sign )   \ read leading minus sign if it is there
  dup c@  [char] - =  IF 1+  -1 ELSE 1 THEN ;
: >number  ( str -- n )         \ convert string to signed number
  get-sign swap  >unumber  * ;


\ Add number conversion to the outer interpreter

: convert-number             \ Convert number at `here`, compile it if necessary
  here >number  state @ IF literal, THEN ;

' convert-number word? !        \ Activate number conversion


2 base !
1010 base !   \ going decimal

: binary     2 base ! ;
: octal      8 base ! ;
: decimal   10 base ! ;
: hex       16 base ! ;


\ Conversion: numbers to string (Modified f.i.g. model.)

128 Constant /numbuf
Create numbuf  /numbuf 1+ allot
Variable 'num                  \ points to the beginning of the generated string

: #>digit ( n - char )
  dup 10 <  IF [char] 0 +  ELSE  10 - [char] a +  THEN ;

: hold   ( char -- )  -1 'num +!   'num @  c! ;
: hold-sign ( n -- )   0< IF  [char] - hold  THEN ;

: <#	            numbuf /numbuf + 'num !   0 hold ;
: # ( u -- u')	    base @ u/mod  #>digit hold ;
: #s ( u -- )	    BEGIN  ?dup WHILE  # REPEAT ;
: #> ( -- addr )    'num @ ;

: (u.)  ( u -- addr )    <# # #s #> ;
: u.    ( u -- )    (u.) puts space ;
: (.)   ( n -- addr )    dup abs  <# # #s hold-sign #> ;
: .     ( n -- )    (.)  puts space ;


\ Line input

: ?split   ( addr c -- )     \ if character at `addr` is `c`, split string there
  over c@ = IF  0 swap c!  ELSE drop THEN ;
: chomp  ( str -- )             \ remove trailing end-of-line character.
  dup strlen + 1-  #eol  ?split ;

: accept  ( addr n -- n' )
  over swap  1+ gets IF  dup chomp strlen ELSE  0 swap c!  drop 0 THEN ;

256 Constant /linebuf
Create linebuf  /linebuf 1+ allot


0 cell+ Constant /cell

: perform ( `xt -- )   @ execute ;

: later   rr> >r ;
: push ( addr -- )       \ Save content of addr during execution of current word
  dup >rr @ >rr  later  r> r> ! ;

: h. ( n -- )   base push  hex . ;


: Textstream	Create /textstream allot ;

: Field  ( offset size -- offset' )   Create over ,  +
  does>  ( 'base -- 'field )          @ + ;

/textstream
  /cell Field >'current-char         \ points to the current character
Constant /stringstream

: strstream-forward   ( 'stream -- )        >'current-char  1 swap +! ;
: strstream-current@  ( 'stream -- char )   >'current-char @ c@ ;
: strstream-eos       ( 'stream -- flag )   strstream-current@ 0= ;

: Stringstream  Create here  /stringstream allot
  ['] strstream-forward  over >forward !
  ['] strstream-current@ over >current@ !
  ['] strstream-eos      over >eos !
  0 over >#eos !
  drop ;

: interpret-stream ( 'string 'stream -- )
  'instream push  dup 'instream !  >'current-char !  do-stream ;

Stringstream line-stream

: line-interpret
  BEGIN  linebuf /linebuf accept drop
         linebuf line-stream interpret-stream
         ." ok" cr  REPEAT ;

: on  ( addr -- )   true swap ! ; \ (L)
: off ( addr -- )   false swap ! ; \ (L)

Variable start-finished		\ Has start-command been executed?
start-finished off

: command-interpret
  start-command @  start-finished @ or IF  start-finished off
      start-command @ line-stream interpret-stream  THEN
  interactive-mode @ IF
      line-interpret ELSE bye THEN ;

' command-interpret 'abort !


\ Debug and Display

: .s                            \ print content of stack
  ?stack  sp@ >r  s0 @  BEGIN  dup r@ u>= WHILE  dup @ h.  cell- REPEAT
  drop rdrop ;

: .name   ( xt -- )   >name puts ;
: words   latest  BEGIN @  ?dup WHILE  dup link> .name space  REPEAT ;


\ Local Variables:
\ comment-start: "\\ "
\ End: