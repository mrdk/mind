\ Tests of built-in words
.( Line: ) line# @ h.  cr

\ here here h. ," teststring" here h. puts cr
\ align here h. cr

\ (') h. h. (') cr execute

\ here ," testword" ^dovar entry, 1 ,  \ 0 testword !
\ .( testword:  ) testword h. cr
\ .( here:      ) here h. cr
\ .( value: )     testword @ h. cr

\ Defining words						. o ( mind )

here ," Create-as"  ^docol entry,	( 'interpreter "name" -- )
	] parse  dup strlen 1+ allot  swap entry,  ;; [

^dodefer Create-as ?pairs  (') 2drop ,  ( n1 n2 -- ) 

^docol Create-as :			( "name" -- )
	] ^docol Create-as  1 state !   lit :  ;; [
: ;	lit : ?pairs   lit ;; ,   0 state !   ;; [
        drop                                    \ drop flag created by :
	#immediate  latest @ link>  flags!	\ make immediate

: 'latest ( -- cfa )    latest @ link> ;
: immediate   'latest dup flags@  #immediate or  swap flags! ;

: Create  ^dovar Create-as ;
: does>   'latest  ^dodoes over !   r> swap >doer ! ;

: Defer ( cfa -- )   ^dodefer Create-as , ;
\ (') cr Defer ccr  ccr

: Variable ( -- )   Create  1 cells allot ;
: Constant ( n -- )   Create ,  does> @ ;
\ 1 Variable v   'latest flags@ h. cr
\ 1 Constant c .( c defined, value=)  c h.  cr


\ Literals and inline strings

: .name   ( cfa -- )   >name puts ;

(') drop Defer ?exists ( cfa -- ) \ Abort if word does not exist

: '	( --- cfa )	(') dup ?exists ;
: [compile]  	' , ;  immediate
: literal,	( n -- )	lit lit ,  , ; \ create { ' lit | n } in dict.
' literal, Defer literal ( n -- ) immediate
\ : literal-test	[ 1 1 + ] literal h. cr ; literal-test
: [']   ' literal, ;  immediate
\ : test[']	['] cr .name cr  ['] ' .name cr ;   test[']

: >mark  ( -- a )	align  here 0 , ;
: >resolve  ( a )	align  here swap ! ;

\ data structure: { ' inline-data | ' end | data ... | }
\ return address of data following in code, relative to the word calling
\ inline-data
: inline-data ( -- a )   r> r>   dup @ >r  cell+  swap >r ;

: (.")  ( -- )     inline-data puts ;
: (")   ( -- a )   inline-data ;

: Stringlit ( cfa -- )   Create ,  immediate  does>  @ ,  >mark  ," >resolve ;

' (.") Stringlit ."
' (")  Stringlit  "

\ : test."   ." 123456" cr ;       test."
\ : test"     " 12345"  puts cr ;  test"

: IF   ( -- a )      ['] 0branch ,  >mark ;  immediate
: ELSE ( a1 -- a2 )  ['] branch ,   >mark  swap >resolve ;  immediate
: THEN ( a -- )      >resolve ;  immediate

\ : test-if-else ( f -- )   dup h. IF ." IF" cr  ELSE ." ELSE" cr THEN ;
\ 0 test-if-else  1 test-if-else
\ : test-if      ( f -- )   dup h. IF ." IF" THEN cr ;
\ 0 test-if  1 test-if

: <mark ( -- a )	align here ;
: <resolve ( a -- )	, ;
: >resolve-all ( a1 ... an n -- )
   0;  swap >resolve  1- >resolve-all ;

: BEGIN ( -- 0 a )	0 <mark ;  immediate
: WHILE ( n a -- a' n+1 a )
    >r  ['] 0branch ,  >mark  swap 1+  r> ;  immediate
: REPEAT ( a1 ... an n a -- )
    ['] branch ,  <resolve  >resolve-all ;  immediate

\ : test-loop  BEGIN ." l" dup h. cr  dup 1- WHILE  dup WHILE  1-  REPEAT h. ;
\ 2 2 * test-loop

\ Characters
: char ( -- c )		parse c@ ;
: [char]	char literal, ;  immediate
\ char A emit cr
\ : test[char]   [char] x emit cr ;  test[char]

: space    blank emit ;
: spaces   BEGIN  ?dup WHILE 1- space REPEAT ;
\ 2 2 2 * * spaces .( spaces) cr


\ Debug tools

: .abort    ( str -- )	       ." Abort: "  here puts  space puts  cr ;
: do-abort  ( flag str -- )    swap IF .abort  abort  ELSE drop THEN ;
: (abort")  ( f -- )   inline-data do-abort ;
' (abort") Stringlit abort"

: depth ( -- n )   s0 @ cell-  sp@ - [ 1 cells ] literal  / ;
: ?stack   depth 0< abort" Stack empty" ;

: .s    ?stack  sp@ >r  s0 @
    BEGIN  dup r u> WHILE  cell-  dup @ h.  REPEAT  drop rdrop ;


\ Conversion: string > number

0  Constant false
-1 Constant true

: within+  ( n n0 n1 -- flag )	1+ within ; \ true if n0 <= n <= n1

Variable base	2 base !	\ Base for number conversion.

Variable #acc			\ Number accumulator
: accumulate ( n -- )	#acc @  base @ u* +  #acc ! ;

: digit?     ( n -- ? )	base @ u< ;
: digit>#  ( c -- n ? )
  dup  [char] 0 [char] 9 within+  IF  [char] 0 -  dup digit? ;; THEN
  dup  [char] a [char] z within+  IF  [char] a -
                     [ 1 2* 2* 1+ 2* ] literal +  dup digit? ;; THEN
  false ;			 

: udigits    ( a -- a' )	\ Accumulate first unsigned digits
  BEGIN dup c@  digit># IF accumulate ELSE drop ;; THEN  1+ REPEAT ;
: ?rest    ( a -- )	c@ abort" not found" ;	\ Abort if not a number
: >unumber ( a -- n )	0 #acc !  udigits ?rest  #acc @ ;
\ : test-unumber  parse  >unumber  h. cr ;
\ test-unumber 1001
\ test-unumber 1001x

: get-sign ( a -- a' sign )	dup c@  [char] - =  IF 1+  -1 ELSE 1 THEN ;
: >number  ( a -- n ) 	   	get-sign swap  >unumber  * ;
\ : test-number  parse  >number  h. cr ;
\ test-number -1001

\ Add number conversion to the outer interpreter

: convert-number   here >number  state @ IF literal, THEN ;
' convert-number word? !     \ Add number conversion

\ : compile-test   110 h. cr ;  compile-test

1010 base !   \ going decimal

: binary     2 base ! ;
: octal      8 base ! ;
: decimal   10 base ! ;
: hex       16 base ! ;

\ Conversion: numbers > string (Modified f.i.g. model.)

128 Constant /numbuf
Create numbuf  /numbuf 1+ allot 
Variable created-string

: hold ( char -- )  -1 created-string +!   created-string @  c! ;
: hold-sign ( n -- )   dup 0< IF  [char] - hold  ELSE drop THEN ;
: <#	 numbuf /numbuf + created-string !   0 hold ;
: # ( u -- u')	    base @ u/mod
  dup 10 <  IF [char] 0 +  ELSE  10 - [char] a +  THEN  hold ;
: #s ( u -- )	    BEGIN  ?dup WHILE  # REPEAT ;
: #> ( -- addr )    created-string @ ;

: (u.)  ( u -- )    <# # #s #> puts ;
: u.    ( u -- )    (u.) space ;
: (.)   ( n -- )    dup abs  <# # #s hold-sign #>  puts ;
: .     ( n -- )    (.) space ;


\ Words

: words   latest  BEGIN @  ?dup WHILE  dup link> .name space  REPEAT ;
\ words cr

\ Last page
.( Line: ) line# @ h.  cr

\ Local Variables:
\ comment-start: "\\ "
\ End:
